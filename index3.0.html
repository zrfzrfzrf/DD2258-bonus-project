<!DOCTYPE html>
<html>
<head>
    <title>AR Gesture Viz Bonus Project - Pro</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: sans-serif; }
        #video { position: absolute; visibility: hidden; }
        canvas { position: absolute; top: 0; left: 0; }
        
        /* 调色条 UI */
        #colorBar {
            position: absolute;
            left: 30px;
            top: 20%;
            width: 25px;
            height: 60%;
            background: linear-gradient(to bottom, 
                #ff0000 0%, 
                #ffff00 17%, 
                #00ff00 33%, 
                #00ffff 50%, 
                #0000ff 67%, 
                #ff00ff 83%, 
                #ff0000 100%);
            border: 2px solid white;
            border-radius: 15px;
            display: none; 
            z-index: 100;
        }
        #cursor {
            position: absolute;
            width: 35px;
            left: -7px;
            height: 6px;
            background: white;
            border: 1px solid black;
            top: 50%;
            transition: top 0.1s;
        }
        #info {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.5);
            padding: 10px;
            border-radius: 5px;
            pointer-events: none;
            text-align: center;
        }
    </style>
</head>
<body>
    <video id="video" playsinline></video>
    
    <div id="colorBar">
        <div id="cursor"></div>
    </div>

    <div id="info">
        Keys: 0 (Line), 1 (Cube), 2(Sphere), 3(Cylinder), 4(Cone) | Z (Undo), C (Clear), P (Lock Color), U(adjust light source)
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        const colorBar = document.getElementById('colorBar');
        const cursor = document.getElementById('cursor');

        let scene, camera, renderer;
        let meshes = []; 
        let points = []; 
        let currentLine = null; 
        let previewMesh = null; 
        let currentShapeType = 'cube'; 
        let lastFinalizeTime = 0; 
        const COOLDOWN_MS = 800; 
        let currentColor = new THREE.Color(0x00ffcc); 
        let savedColor = new THREE.Color(0x00ffcc);  
        let isColorLocked = false; 
        
        // 灯光变量
        let pointLight, lightSphere;
        let isLightMode = true; 

        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 5;

            // 1. 基础环境光（较暗，为点光源留出空间）
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.4);
            scene.add(ambientLight);

            // 2. 动态点光源
            pointLight = new THREE.PointLight(0xffffff, 1.5, 20);
            pointLight.position.set(2, 2, 2);
            scene.add(pointLight);

            // 3. 光源指示器（小球）
            const sphereGeo = new THREE.SphereGeometry(0.1, 16, 16);
            const sphereMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
            lightSphere = new THREE.Mesh(sphereGeo, sphereMat);
            scene.add(lightSphere);
        }

        window.addEventListener('keydown', (e) => {
            const keys = {'0':'line', '1':'cube', '2':'sphere', '3':'cylinder', '4':'cone'};
            if (keys[e.key]) {
                currentShapeType = keys[e.key];
                if (previewMesh) { scene.remove(previewMesh); previewMesh = null; }
            }
            if (e.key.toLowerCase() === 'z' && meshes.length > 0) {
                const last = meshes.pop();
                scene.remove(last);
            }
            if (e.key.toLowerCase() === 'c') {
                meshes.forEach(m => scene.remove(m));
                meshes = [];
            }
            if (e.key.toLowerCase() === 'p') {
                isColorLocked = !isColorLocked;
                colorBar.style.opacity = isColorLocked ? "0.3" : "1.0";
                console.log("Color Lock:", isColorLocked);
            }
            if (e.key.toLowerCase() === 'u') {
                isLightMode = !isLightMode;
                lightSphere.visible = isLightMode;
                console.log("Light Follow:", isLightMode);
            }
        });

        function onResults(results) {
            let rightHand = null; 
            let leftHand = null;  

            if (results.multiHandLandmarks && results.multiHandedness) {
                results.multiHandLandmarks.forEach((landmarks, index) => {
                    const label = results.multiHandedness[index].label;
                    if (label === 'Left') rightHand = landmarks; 
                    if (label === 'Right') leftHand = landmarks;
                });
            }

            // 处理左手 (调色 + 灯光)
            if (leftHand) {
                // 1. 调色逻辑
                if (!isColorLocked) {
                    colorBar.style.display = 'block';
                    const lThumb = leftHand[4];
                    const lIndex = leftHand[8];
                    let diff = lThumb.y - lIndex.y; 
                    let hueValue = diff / 0.2 - 0.2;
                    hueValue = Math.min(Math.max(hueValue, 0), 1);
                    savedColor.setHSL(hueValue, 0.9, 0.5);
                    currentColor.copy(savedColor);
                    cursor.style.top = (hueValue * 100) + '%';
                }

                // 2. 灯光随动逻辑 (跟随左手掌心)
                if (isLightMode) {
                    const lPalm = leftHand[9]; // 中指根部，靠近掌心
                    const lightPos = new THREE.Vector3(
                        -(lPalm.x - 0.5) * 10, 
                        -(lPalm.y - 0.5) * 6, 
                        -lPalm.z * 10
                    );
                    pointLight.position.copy(lightPos);
                    lightSphere.position.copy(lightPos);
                }
            } else {
                if (!isColorLocked) colorBar.style.display = 'none';
            }

            // 处理右手 (绘图)
            if (rightHand) {
                const rThumb = rightHand[4];
                const rIndex = rightHand[8];
                const rMiddle = rightHand[12];

                const posIndex = new THREE.Vector3(-(rIndex.x - 0.5) * 10, -(rIndex.y - 0.5) * 6, -rIndex.z * 10);
                const posThumb = new THREE.Vector3(-(rThumb.x - 0.5) * 10, -(rThumb.y - 0.5) * 6, -rThumb.z * 10);
                const midPos = new THREE.Vector3().addVectors(posIndex, posThumb).multiplyScalar(0.5);
                
                const distIndexThumb = posIndex.distanceTo(posThumb);
                const distMiddleThumb = Math.sqrt(Math.pow(rMiddle.x - rThumb.x, 2) + Math.pow(rMiddle.y - rThumb.y, 2));

                const isIndexPinching = distIndexThumb < 2.5; 
                const isMiddlePinching = distMiddleThumb < 0.07;

                if (currentShapeType === 'line') {
                    if (isIndexPinching) {
                        points.push(midPos.clone());
                        updateLine();
                    } else {
                        points = []; currentLine = null;
                    }
                } else {
                    if (isIndexPinching) {
                        updatePreview(midPos, distIndexThumb, posIndex);
                        const now = Date.now();
                        if (isMiddlePinching && previewMesh && (now - lastFinalizeTime > COOLDOWN_MS)) {
                            finalizeShape();
                            lastFinalizeTime = now;
                        }
                    } else if (previewMesh) {
                        scene.remove(previewMesh);
                        previewMesh = null;
                    }
                }
            }
            renderer.render(scene, camera);
        }

        function updateLine() {
            if (!currentLine) {
                const geo = new THREE.BufferGeometry();
                const mat = new THREE.LineBasicMaterial({ color: currentColor.clone(), linewidth: 5 });
                currentLine = new THREE.Line(geo, mat);
                scene.add(currentLine);
                meshes.push(currentLine);
            }
            currentLine.geometry.setFromPoints(points);
        }

        function updatePreview(pos, distance, targetPos) {
            if (!previewMesh) {
                let geo;
                if (currentShapeType === 'cube') geo = new THREE.BoxGeometry(1, 1, 1);
                if (currentShapeType === 'sphere') geo = new THREE.SphereGeometry(0.6, 32, 32);
                if (currentShapeType === 'cylinder') geo = new THREE.CylinderGeometry(0.4, 0.4, 1, 32);
                if (currentShapeType === 'cone') geo = new THREE.ConeGeometry(0.5, 1, 32);

                previewMesh = new THREE.Mesh(geo, new THREE.MeshStandardMaterial({ 
                    transparent: true, opacity: 0.6, metalness: 0.6, roughness: 0.2 
                }));
                scene.add(previewMesh);
            }
            previewMesh.position.copy(pos);
            previewMesh.material.color.copy(currentColor);
            const s = Math.max(0.1, distance * 1.2);
            previewMesh.scale.set(s, s, s);
            
            previewMesh.lookAt(targetPos);
            if (currentShapeType === 'cylinder' || currentShapeType === 'cone') {
                previewMesh.rotateX(Math.PI / 2);
            }
        }

        function finalizeShape() {
            const final = previewMesh.clone();
            final.material = new THREE.MeshStandardMaterial({
                color: savedColor.clone(),
                metalness: 0.6,
                roughness: 0.2
            });
            scene.add(final);
            meshes.push(final);
            scene.remove(previewMesh);
            previewMesh = null;
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.6 });
        hands.onResults(onResults);

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });

        initThree();
        cameraMP.start();
    </script>
</body>
</html>