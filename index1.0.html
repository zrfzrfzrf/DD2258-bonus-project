<!DOCTYPE html>
<html>
<head>
    <title>AR Gesture Viz Bonus Project</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; }
        #video { position: absolute; visibility: hidden; }
        canvas { position: absolute; top: 0; left: 0; }
    </style>
</head>
<body>
    <video id="video" playsinline></video>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        const videoElement = document.getElementById('video');
        let scene, camera, renderer;
        let meshes = []; // å¿…é¡»å®šä¹‰è¿™ä¸ªæ•°ç»„ï¼
        let points = []; 
        let currentLine = null; // ç”¨äºå­˜å‚¨å½“å‰æ­£åœ¨ç”»çš„é‚£æ ¹çº¿
        let previewMesh = null; 
        let currentShapeType = 'cube'; // é»˜è®¤åˆå§‹å½¢çŠ¶
        let lastFinalizeTime = 0; // è®°å½•ä¸Šä¸€æ¬¡æ”¾ç½®çš„æ—¶é—´æˆ³
        const COOLDOWN_MS = 1000; // å†·å´æ—¶é—´ï¼Œ1000æ¯«ç§’ï¼ˆ1ç§’ï¼‰
        let currentColor = new THREE.Color(0x00ffcc);
        let leftHandVisible = false;

        // 1. åˆå§‹åŒ–åœºæ™¯
        function initThree() {
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);
            camera.position.z = 5;

            // æ·»åŠ ä¸€ä¸ªç¯å¢ƒå…‰ï¼Œè®©ç‰©ä½“æ›´å¥½çœ‹
            const light = new THREE.AmbientLight(0xffffff, 1);
            scene.add(light);
        }

        // ç›‘å¬é”®ç›˜åˆ‡æ¢
        window.addEventListener('keydown', (e) => {
            const keys = {'0':'line', '1':'cube', '2':'sphere', '3':'cylinder', '4':'cone'};
            if (keys[e.key]) {
                currentShapeType = keys[e.key];
                // åˆ‡æ¢æ¨¡å¼æ—¶æ¸…ç©ºé¢„è§ˆï¼Œé˜²æ­¢å½¢çŠ¶æ··ä¹±
                if (previewMesh) {
                    scene.remove(previewMesh);
                    previewMesh = null;
                }
                console.log("å½“å‰æ¨¡å¼:", currentShapeType);
            }
            // æ’¤é”€
            if (e.key.toLowerCase() === 'z') {
                if (meshes.length > 0) {
                    const lastMesh = meshes.pop();
                    scene.remove(lastMesh);
                    console.log("å·²æ’¤é”€ä¸Šä¸€ä¸ªç‰©ä½“");
                }
            }
            // æ¸…å±
            if (e.key === 'c' || e.key === 'C') {
                meshes.forEach(m => scene.remove(m));
                meshes = [];
                console.log("ç”»å¸ƒå·²æ¸…ç©º");
            }
        });

        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const hand = results.multiHandLandmarks[0];
                const thumbTip = hand[4];
                const indexTip = hand[8];
                const middleTip = hand[12]; // ä¸­æŒ‡å°–

                // 1. åæ ‡æ˜ å°„ (å·²ä¿®å¤é•œåƒ)
                const pos = new THREE.Vector3(-(indexTip.x - 0.5) * 10, -(indexTip.y - 0.5) * 6, -indexTip.z * 10);
                
                // 2. è®¡ç®—é—´è·
                // é£ŸæŒ‡-å¤§æ‹‡æŒ‡ï¼šç”¨äºæ§åˆ¶å¤§å°
                const distIndexThumb = Math.sqrt(Math.pow(indexTip.x - thumbTip.x, 2) + Math.pow(indexTip.y - thumbTip.y, 2));
                // ä¸­æŒ‡-å¤§æ‹‡æŒ‡ï¼šç”¨äºç¡®è®¤æ”¾ç½® (Action Key)
                const distMiddleThumb = Math.sqrt(Math.pow(middleTip.x - thumbTip.x, 2) + Math.pow(middleTip.y - thumbTip.y, 2));

                // --- é€»è¾‘åˆ¤æ–­ ---
                const isIndexPinching = distIndexThumb < 0.3;  // é£ŸæŒ‡å¤§æ‹‡æŒ‡é è¿‘ï¼šæ¿€æ´»/è°ƒæ•´
                const isMiddlePinching = distMiddleThumb < 0.06; // ä¸­æŒ‡å¤§æ‹‡æŒ‡ç¢°è§¦ï¼šå®šæ ¼

                if (currentShapeType === 'line') {
                    // åˆ’çº¿é€»è¾‘ä¿æŒç›¸å¯¹ç®€å•ï¼Œæˆ–è€…ä¹Ÿå¯ä»¥ç”¨ä¸­æŒ‡æ§åˆ¶å¼€å…³
                    if (isIndexPinching) {
                        points.push(pos.clone());
                        updateLine();
                    } else {
                        points = []; 
                        currentLine = null;
                    }
                } else {
                // åœ¨ onResults å‡½æ•°å†…éƒ¨
                if (isIndexPinching) {
                    updatePreview(pos, distIndexThumb);
                    
                    // å¢åŠ æ—¶é—´åˆ¤å®šï¼šä¸­æŒ‡ç¢°å¤§æ‹‡æŒ‡ ä¸” è·ç¦»ä¸Šæ¬¡æ”¾ç½®è¶…è¿‡ 1 ç§’
                    const currentTime = Date.now();
                    if (isMiddlePinching && previewMesh && (currentTime - lastFinalizeTime > COOLDOWN_MS)) {
                        finalizeShape();
                        lastFinalizeTime = currentTime; // æ›´æ–°æœ€åä¸€æ¬¡æ”¾ç½®çš„æ—¶é—´
                    }
                } else {
                    if (previewMesh) {
                        scene.remove(previewMesh);
                        previewMesh = null;
                    }
                }
                }
            }
            renderer.render(scene, camera);
        }

        function updateLine() {
            if (!currentLine) {
                const geometry = new THREE.BufferGeometry();
                const material = new THREE.LineBasicMaterial({ color: 0x00ffcc, linewidth: 5 });
                currentLine = new THREE.Line(geometry, material);
                scene.add(currentLine);
                meshes.push(currentLine); // å­˜å…¥æ•°ç»„æ–¹ä¾¿ç®¡ç†
            }
            currentLine.geometry.setFromPoints(points);
        }

        function updatePreview(pos, distance) {
            if (!previewMesh) {
                let geo;
                if (currentShapeType === 'cube') geo = new THREE.BoxGeometry(1, 1, 1);
                if (currentShapeType === 'sphere') geo = new THREE.SphereGeometry(1, 32, 32);
                if (currentShapeType === 'cylinder') geo = new THREE.CylinderGeometry(0.5, 0.5, 1, 32);
                if (currentShapeType === 'cone') geo = new THREE.ConeGeometry(0.5, 1, 32);

                previewMesh = new THREE.Mesh(geo, new THREE.MeshNormalMaterial({ transparent: true, opacity: 0.6 }));
                scene.add(previewMesh);
            }
            previewMesh.position.copy(pos);

            // é—´è·æ˜ å°„ï¼šdistance è¶Šå¤§ï¼Œç‰©ä½“è¶Šå¤§
            // è¿™é‡Œçš„ 15 æ˜¯çµæ•åº¦ç³»æ•°ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦è°ƒæˆ 10 æˆ– 20
            const scale = Math.max(0.05, distance * 5); 
            previewMesh.scale.set(scale, scale, scale);
        }

        function finalizeShape() {
            const finalMesh = previewMesh.clone();
            finalMesh.material = new THREE.MeshNormalMaterial(); // å˜ä¸ºä¸é€æ˜å®ä½“
            
            // ğŸ’¡ å°æŠ€å·§ï¼šç»™æ”¾ç½®å¥½çš„ç‰©ä½“ä¸€ä¸ªå¾®å°çš„éšæœºæ—‹è½¬ï¼Œ
            // è¿™æ ·å³ä¾¿ä½ çœŸçš„æ”¾é‡å äº†ï¼Œä¹Ÿèƒ½ä¸€çœ¼çœ‹å‡ºæ˜¯ä¸¤ä¸ªç‰©ä½“
            finalMesh.rotation.set(Math.random()*0.1, Math.random()*0.1, Math.random()*0.1);
            
            scene.add(finalMesh);
            meshes.push(finalMesh);
            
            // æ”¾ç½®åç«‹å³é”€æ¯é¢„è§ˆ
            scene.remove(previewMesh);
            previewMesh = null;

            // å¯ä»¥åœ¨æ§åˆ¶å°æ‰“å°ä¸€ä¸‹ï¼Œæ–¹ä¾¿ä½ è°ƒè¯•
            console.log("ç‰©ä½“å·²å›ºå®šï¼Œæ€»æ•°:", meshes.length);
        }

        // å¯åŠ¨æ­¥å¥
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5 });
        hands.onResults(onResults);

        const cameraMP = new Camera(videoElement, {
            onFrame: async () => { await hands.send({image: videoElement}); },
            width: 1280, height: 720
        });

        initThree();
        cameraMP.start();
    </script>
</body>
</html>
